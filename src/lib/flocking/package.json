{
  "_args": [
    [
      "flocking@git+https://github.com/colinbdclark/Flocking.git",
      "/Users/aharnum/work/chartAuthoring/chartAuthoring"
    ]
  ],
  "_from": "git+https://github.com/colinbdclark/Flocking.git",
  "_id": "flocking@0.2.0-dev",
  "_inCache": true,
  "_installable": true,
  "_location": "/flocking",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/colinbdclark/Flocking/master/package.json",
      "gitUrl": "git://github.com/colinbdclark/Flocking.git",
      "httpsUrl": "git+https://github.com/colinbdclark/Flocking.git",
      "shortcut": "github:colinbdclark/Flocking",
      "ssh": "git@github.com:colinbdclark/Flocking.git",
      "sshUrl": "git+ssh://git@github.com/colinbdclark/Flocking.git",
      "type": "github"
    },
    "name": "flocking",
    "raw": "flocking@git+https://github.com/colinbdclark/Flocking.git",
    "rawSpec": "git+https://github.com/colinbdclark/Flocking.git",
    "scope": null,
    "spec": "git+https://github.com/colinbdclark/Flocking.git",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+https://github.com/colinbdclark/Flocking.git#b3e07384cc2561ba9d57bf7ff299b2242aec3d74",
  "_shasum": "a2c3c0e0e8fae7b8ea33c2bc0ff454c74d69454d",
  "_shrinkwrap": null,
  "_spec": "flocking@git+https://github.com/colinbdclark/Flocking.git",
  "_where": "/Users/aharnum/work/chartAuthoring/chartAuthoring",
  "author": {
    "name": "Colin Clark"
  },
  "bugs": {
    "url": "http://github.com/colinbdclark/Flocking/issues"
  },
  "dependencies": {
    "codemirror-infusion": "github:colinbdclark/codemirror-infusion#gh-6",
    "dagre": "0.7.4",
    "infusion": "2.0.0-dev.20160309T145652Z.9f515ec",
    "jquery": "2.1.4",
    "jsplumb": "1.7.9",
    "midi": "0.9.4",
    "normalize.css": "3.0.3",
    "speaker": "github:colinbdclark/node-speaker#mpg123-lower-latency"
  },
  "description": "Creative audio synthesis for the Web and Node.js",
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-contrib-clean": "~0.4.1",
    "grunt-contrib-concat": "~0.3.0",
    "grunt-contrib-copy": "~0.4.1",
    "grunt-contrib-jshint": "~0.8.0",
    "grunt-contrib-uglify": "~0.3.2",
    "grunt-contrib-watch": "^0.6.1",
    "sheep-benchmark": "github:colinbdclark/sheep.js"
  },
  "engines": {
    "node": ">=0.10.x"
  },
  "gitHead": "b3e07384cc2561ba9d57bf7ff299b2242aec3d74",
  "homepage": "http://flockingjs.org/",
  "keywords": [
    "Flocking",
    "WebAudio",
    "sound",
    "audio",
    "music",
    "synthesis"
  ],
  "license": "(MIT OR GPL-2.0)",
  "main": "index.js",
  "name": "flocking",
  "optionalDependencies": {
    "midi": "0.9.4",
    "speaker": "colinbdclark/node-speaker#mpg123-lower-latency"
  },
  "readme": "Flocking - Creative audio synthesis for the Web!\n================================================\n\nWhat is Flocking?\n-----------------\n\nFlocking is a JavaScript audio synthesis framework designed for artists and musicians\nwho are building creative and experimental Web-based sound projects.\nIt supports Firefox, Chrome, Safari, and Node.js on\nMac OS X, Windows, Linux, iOS, and Android.\n\nUnlike comparable tools, Flocking is declarative. Its goal is to promote a uniquely\ncommunity-minded approach to instrument design and composition.\nIn Flocking, unit generators and synths are specified as JSON,\nmaking it easy to save, share, and manipulate your synthesis algorithms.\nSend your synths via Ajax, save them for later using HTML5 local data storage,\nor algorithmically produce new instruments on the fly.\n\nBecause it's just JSON, every instrument you build using Flocking can be easily modified\nand extended by others without forcing them to fork or cut and paste your code.\nThis declarative approach will also help make it easier to create new authoring,\nperformance, metaprogramming, and social tools on top of Flocking.\n\nFlocking was inspired by the [SuperCollider](http://supercollider.sourceforge.net/)\ndesktop synthesis environment. If you're familiar with SuperCollider,\nyou'll feel at home with Flocking.\n\nTo learn more about Flocking's architecture and approach, please see:\n\nClark, C. and Tindale, Adam. \"[Flocking: A Framework for Declarative Music-Making on the Web](https://github.com/colinbdclark/flocking-papers/blob/master/icmc-2014/flockingicmc2014.pdf?raw=true)\"\nin Georgaki, A. and Kouroupetroglou (eds.). _The Joint Proceedings of the ICMC and SMC_, (2014).\n_[slides](colinclark.org/presentations/flocking-icmc-2014-slides.pdf)_\n\n\n\nCommunity\n---------\n\nFlocking has an inclusive and supportive community with several forums where you can ask for help\nand share the projects you're working on.\n\n### Mailing List\nThe [flocking mailing list](http://lists.idrc.ocadu.ca/mailman/listinfo/flocking)\nis the place to ask questions, share code, and request new features.\n\n### Chat\nFlocking has an IRC channel. Join <code>#flocking</code> on <code>irc.freenode.net</code>.\n\n\nStatus and Roadmap\n------------------\n\nFlocking is in active development. It has bugs and it is growing quickly.\n\nThe project's [development roadmap](https://github.com/colinbdclark/Flocking/wiki/Release-Plan)\nis documented in the wiki. Plans include:\n * Better support for interleaving Flocking unit generators with Web Audio API nodes\n * A new format for specifying connections between unit generators\n * A \"live data merging\" environment for live coding\n * Graphical editing of Flocking synth defs\n * A block-accurate scheduler and more sample-accurate scheduling unit generators\n * Multichannel expansion\n\nUnplanned features, bug fixes, and contributions are welcome and appreciated, of course. The Flocking project adheres to the [Contributor Covenant guidelines](http://contributor-covenant.org/version/1/2/0/), and is an open and welcoming community.\n\n\nDocumentation and Demos\n-----------------------\n\n* Flocking's [documentation](docs/) is in the repository\n* Demos can be found in the Flocking Playground\n    * [Latest stable release](http://flockingjs.org/demos/interactive/html/playground.html)\n    * [Unreleased development version](http://flockingjs.org/next/demos/playground/)\n    * [Preview of the new graphical playground](http://flockingjs.org/next/demos/playground/live/)\n* Other examples are located in the [examples repository](http://github.com/colinbdclark/flocking-examples)\n\n\nGetting Started\n---------------\n\nThe latest stable release of Flocking is version 0.1.2. It can be downloaded from the [Flocking releases](https://github.com/colinbdclark/Flocking/releases) page.\n\nConcatenated and minified Flocking builds, suitable for development and production respectively,\nare included in the [dist directory](dist/). Flocking can also be built manually using Grunt.\n\nHere's how to include Flocking's development file in your HTML page:\n\n    <!-- This includes Flocking and all its dependencies, including jQuery 2.1.3 and Infusion -->\n    <script src=\"flocking/dist/flocking-all.js\"></script>\n\n\nFor more information on using Flocking in a browser,\nread the [Getting Started](docs/getting-started.md) tutorial.\nIf module loaders are your thing, Flocking also supports the CommonJS and AMD styles.\n\nIf you're interested in using Flocking with Node.js,\nread the [Flocking in Node.js](docs/nodejs.md) tutorial.\n\n\nUsing Flocking\n--------------\n\nFlocking consists of a handful of primary components that are configured using JSON\nspecifications. These include: Unit Generators (ugens), Synths, Schedulers, and the Environment.\n\n### Unit Generators ##\n\nUnit generators, or _ugens_ for short, are the basic building blocks of synthesis;\nthey do the work of generating or processing audio signals in Flocking.\nUGens have multiple inputs and a single output. Some unit generators support\nmultiple input or output multiple channels.\n\nA unit generator can be wired to other unit generators,\nsupporting sophisticated signal processing graphs.\nUnit generators implement one primary method, <code>gen(numSamps)</code>,\nwhich is responsible for processing a block of audio samples.\n\nTypically, however, you never need to interact with unit generator instances directly.\nInstead, you create declarative \"unit generator definitions\" (_ugenDefs_) objects,\nletting Flocking take care of creating the actual unit generator instances.\nUGenDefs are composed into trees called _synthDefs_.\nHere's an example of a ugenDef:\n\n    {\n        id: \"carrier\",             // A unique ID used when updating this ugen's input values.\n\n        ugen: \"flock.ugen.sinOsc\", // The fully-qualified name of the desired unit generator,\n                                   // specified as a \"key path\" (a dot-separated string).\n\n        rate: \"audio\",             // The rate at which the unit generator should run.\n\n        inputs: {                  // The input values for this unit generator. Each UGen has different inputs.\n            freq: 440              // For convenience, these inputs don't need to be nested inside the \"inputs\"\n        },                         // container, but you might want to for readability.\n\n        options: {\n            interpolation: \"linear\" // Other non-signal options such as interpolation rates, etc.\n                                    // Options are also specific to the type of unit generator.\n        }\n    }\n\n### Synths ###\n\nA Synth is a self-contained collection of unit generators that represents a\nsynthesizer, instrument, or signal processor of some kind.\nMultiple synths can run at the same time, and they can be connected together\nusing shared interconnect buses.\nFor example, a mixing board Synth could be created to mix and process signals from\nseveral tone-generating Synths and effect Synths.\n\nTo create a synth, you specify a <code>synthDef</code> option, which is a declarative\ntree of unit generator definitions. Here's a simple example of a sine oscillator (named _carrier_)\nwhose amplitude is modulate by another sine oscillator, _mod_:\n\n    {\n        id: \"carrier\",                  // Name this unit generator \"carrier,\" exposing it as an input to the synth.\n        ugen: \"flock.ugen.sinOsc\",      // Sine oscillator ugen.\n        freq: 440,                      // Give it a frequency of 440 Hz, or the A above middle C.\n        mul: {                          // Modulate the amplitude of this ugen with another ugen.\n            id: \"mod\",                      // Name this one \"mod\"\n            ugen: \"flock.ugen.sinOsc\",      // Also of type Sine Oscillator\n            freq: 1.0                       // Give it a frequency of 1 Hz, or one wobble per second.\n        }\n    }\n\nSynths can be updated in realtime by using the <code>get()</code> and <code>set()</code> methods.\nAny unit generator with an <code>id</code> property in its ugenDef will automatically be\nexposed as a named input to the synth. To update a unit generator, a _key path_ is used to specify\nthe desired input. Key paths are dot-delimited, path-like strings that allow you to address any part of the\nunit generator tree. Here's an example of a key path:\n\n    \"carrier.freq.mul\" // Refers to the amplitude (mul) of the carrier's frequency.\n\n#### Getting Synth Inputs ####\n\nAn input can be retrieved from a synth by invoking the <code>get()</code> method with a key path.\nIf the target of the path is a _value unit generator_, its value will be returned directly.\nIf it is any other kind of input, its ugen instance will be returned instead.\n\n    var freq = synth.get(\"carrier.freq\");\n\n#### Setting Synth Inputs ###\n\nSynth inputs can be set by calling the aptly-named <code>set()</code> method.\nFlocking's signal processing pipeline is dynamic, so unit generators can be added\nor replaced at any time. Behind the scenes, everything is a unit generator,\neven static values.\n\nUpdating a value:\n\n    synth.set(\"carrier.freq\", 440);\n\nReplacing the target unit generator with a new one:\n\n    synth.set(\"carrier.freq\", {\n        ugen: \"flock.ugen.sinOsc\",\n        freq: 2\n    });\n\nUpdating multiple inputs at once:\n\n    synth.set({\n        \"carrier.freq\": 440,\n        \"carrier.mul\": 0.5,\n        \"modulator.freq\": 123\n    });\n\n\n### Rates ###\n\nTo ensure reasonable performance on resource-constrained devices such as phones and low-power computers\n(e.g. Chromebooks, Raspberry Pi), Flocking uses a block-based architecture. By default, ugens and synths will\nproduce 64 samples per block. This value is configurable by specifying the <code>blockSize</code>\noption when initializing Flocking.\n\nThere are three primary types of signal rates in Flocking: <code>audio</code>, <code>control</code>,\nand <code>constant</code>. Audio rate produces a full block of samples,\ncontrol rate produces one sample per block, and constant rate will alway produce the same value.\nSynths also support two other rates, <code>demand</code> and <code>scheduled</code>. A demand rate synth\nwill only produce a value when its <code>gen()</code> method is invoked. Scheduled synths are under the\ncontrol of a scheduler instead of the sample output clock.\n\n\n### The Environment ##\n\nAn Environment represents a whole \"audio system\" or \"context\" in Flocking.\nIt is responsible for evaluating all Synths instances and outputting their samples to the\ncurrent audio output strategy. An environment manages a list of Synth instances and evaluates them in order.\nYou should instantiate only one <code>flock.enviro</code> for your entire application.\n\nThe Flocking _shared environment_ is created by calling <code>flock.init()</code>:\n\n    var environment = flock.init();\n\nBefore you'll hear any sound, the environment needs to be started. You only need to start the environment once.\nThis is done using the <code>start()</code> method:\n\n    environment.start();\n\nTo stop the environment from generating samples, use the <code>stop()</code> method:\n\n    environment.stop();\n\n#### Synths and the Environment ####\n\nBy default, synths are automatically added to the end (or _tail_) of the environment's list of synths.\nThis means that synths will start playing immediately when you create them.\n\nIf you want to defer the playing of a Synth to a later time,\nyou can override the <code>addToEnvironment</code> option when you instantiate it:\n\n    var mySynth = flock.synth({\n        synthDef: {\n            ugen: \"flock.ugen.sin\",\n            freq: 440\n        },\n        addToEnvironment: false\n    });\n\nIf you need to manage the Environment's list of synths manually,\nyou can use the methods provided by the flock.nodeListComponent _grade_.\n\nTo add a synth to the head of the graph so that it will be evaluated first:\n\n    enviro.head(mySynth);\n\nTo add a synth to the tail of the graph so that it will be evaluated after all other synths):\n\n    enviro.tail(mySynth);\n\n### Schedulers ###\n\nA scheduler allows you to schedule changes to Synths at a particular time.\nCurrently, there is one type of Scheduler, the asynchronous scheduler.\nUnfortunately, it is driven by the browser's notoriously inaccurate setTimeout() and setInterval() clocks,\nwhich means that it will drift by up to 75 ms depending on the browser's load.\nIn practice, however, this drift is sufficient for scheduling many kinds of changes,\nand if sample-level accuracy is needed, unit generators such as <code>flock.ugen.sequence</code>,\n<code>flock.ugen.change</code> and  <code>flock.ugen.random</code> can be used.\n\nA block-accurate scheduler is planned for an upcoming release of Flocking.\nIn the meantime the asynchronous scheduler does a decent job of keeping \"pleasantly inaccurate\" time.\n\nHere's an example of how to use the Flocking scheduler declaratively:\n\n    // Create a Band containing two components:\n    //   1. a synth named \"sinSynth,\" on which we will schedule changes.\n    //   2. an asynchronous scheduler\n    var band = flock.band({\n        components: {\n            sinSynth: {\n                type: \"flock.synth\",\n                options: {\n                    synthDef: {\n                        id: \"carrier\",\n                        ugen: \"flock.ugen.sinOsc\",\n                        freq: 220,\n                        mul: {\n                            ugen: \"flock.ugen.line\",\n                            start: 0,\n                            end: 0.25,\n                            duration: 1.0\n                        }\n                    }\n                }\n            },\n\n            scheduler: {\n                type: \"flock.scheduler.async\",\n                options: {\n                    components: {\n                        synthContext: \"{sinSynth}\"\n                    },\n\n                    score: [\n                        {\n                            interval: \"repeat\",\n                            time: 1.0,\n                            change: {\n                                values: {\n                                    \"carrier.freq\": {\n                                        synthDef: {\n                                            ugen: \"flock.ugen.sequence\",\n                                            values: [330, 440, 550, 660, 880, 990, 1100, 1210]\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    ]\n                }\n            }\n        }\n    });\n\nIf you need to, you can always schedule arbitrary events using plain old functions:\n\n    // Fade out after 8 seconds.\n    band.scheduler.once(8, function () {\n        band.sinSynth.set({\n            \"carrier.mul.start\": 0.25,\n            \"carrier.mul.end\": 0.0,\n            \"carrier.mul.duration\": 1.0\n        });\n    });\n\nThe Flocking scheduler is still under active development and its API will change as it evolves.\n\n\nCompatibility\n-------------\n\nFlocking is currently tested on the latest versions of Firefox, Chrome, Safari, and Microsoft Edge\non Mac, Windows, Linux, iOS, and Android. Node.js 0.12.x is also supported.\n\n\nLicense\n---------\n\nFlocking is distributed under the terms of both the MIT or GPL 2 Licenses.\nAs a result, you can choose the license that best suits your\nproject. The full text of Flocking's [MIT](MIT_LICENSE.txt) and [GPL](GPL-LICENSE.txt) licenses are at the root of the repository.\n\n\nCredits\n-------\n\nFlocking is developed by Colin Clark and the community.\nIt was named after a composition by [James Tenney](http://www.plainsound.org/JTwork.html),\na composer, thinker, and early pioneer of computer music who was my composition teacher and a\nhuge influence on my work. I hope you find this library useful enough to create projects as\nbeautiful and inspiring as Jim's _Flocking_.\n\n### Thanks to:###\n * [Adam Tindale](http://adamtindale.com) for several of the Playground demos\n * [Johnny Taylor](https://github.com/abledaccess) for styling improvements to the Playground\n * [Dan Stowell](https://github.com/danstowell) for the Freeverb and Delay1 unit generators\n * [Mayank Sanganeria](http://github.com/e7mac) for the <code>flock.ugen.granulator</code> unit generator\n * [Vitus](https://github.com/derDoc) for his contributions to the original version of the interactive Playground\n * [Myles Borins](https://github.com/thealphanerd) for pushing the limits of Flocking early in its development\n * [Antranig Basman](https://github.com/amb26) for code review, architectural advice, and help with maths\n * Alex Geddie for teaching me a ton about synthesis and computer music\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/colinbdclark/Flocking.git"
  },
  "version": "0.2.0-dev"
}
